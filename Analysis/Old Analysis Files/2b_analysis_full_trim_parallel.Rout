
R version 3.6.0 (2019-04-26) -- "Planting of a Tree"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # This version doesn't save full probabilities but rather running mean
> # Doesn't save marginal probabilities or latent factors at all
> 
> # --------- TO DO: set  your directories and name the current results files using the date---------#
> 
> ## YOU REALLY HAVE TO SET THESE ##
> 
> # The directory where the analysis is performed:
> #wd_path <- '/Users/camilledesisto/Documents/GitHub/African-Frugivory'
> #wd_path <- "/home/grad/jnk21/projects/African-Frugivory-V2"
> wd_path<- "/hpc/group/dunsonlab/jkampe/African-Frugivory-V2"
> setwd(wd_path)
> 
> # Save results using convention: res_date_i.rda
> date <- 'May10_FullOcc4_par'
> batchname <- "mcmc_full"
> 
> 
> ## THESE SHOULD BE THE SAME IF YOU CLONED THE REPO ##
> 
> # Where the processed data are saved:
> data_path <- 'ProcessedData/'
> # Where you want to save MCMC results:
> save_path <- 'Results/'
> # Where the functions are available:
> source_path <- 'HelperScriptsNew/'
> 
> # ------ STEP 0: Some functions. --------- #
> 
> source(paste0(source_path, 'UpdExtraVar_function.R'))
> source(paste0(source_path, 'UpdTraitCoef_function.R'))
> source(paste0(source_path, 'UpdLatFac_function.R'))
> source(paste0(source_path, 'UpdProbObs_function.R'))
> source(paste0(source_path, 'UpdOccur_function.R'))
> source(paste0(source_path, 'UpdRho_function.R'))
> source(paste0(source_path, 'OmegaFromV_function.R'))
> source(paste0(source_path, 'useful_functions.R'))
> source(paste0(source_path, 'CorrMat_function.R'))
> source(paste0(source_path, 'MCMC_function_trim.R'))
> source(paste0(source_path, 'PredictInteractions_function.R'))
> source(paste0(source_path, 'GetPredLatFac_function.R'))
> source(paste0(source_path, 'GetPredWeights_function.R'))
> 
> library(doParallel)
Loading required package: foreach
Loading required package: iterators
Loading required package: parallel
> #library(parallel)
> library(foreach)
> library(abind)
> library(magrittr)
> 
> # Loading the data:
> load(paste0(data_path, 'Cu_phylo.dat'))
> load(paste0(data_path, 'Cv_phylo.dat'))
> load(paste0(data_path, 'obs_A_mammals.dat'))
> load(paste0(data_path, 'F_obs_default.dat'))
> load(paste0(data_path, 'Obs_X.dat')) # mammal traits
> load(paste0(data_path, 'Obs_W.dat')) # plant traits
> load(paste0(data_path, 'obs_OM.dat')) # site level obs_OM
> load(paste0(data_path, 'obs_OP.dat')) # site level obs_OP
> 
> # Data for subsetting
> 
> ## Rename for convenience
> Cu <- Cu_phylo
> Cv <- Cv_phylo
> obs_A <- A.obs.m
> obs_W <- Obs_W[, 1:2]
> obs_X <- Obs_X
> 
> # Useful values
> nP <- ncol(obs_A)
> nM <- nrow(obs_A)
> nS <- dim(obs_A)[3]
> 
> # Create alternate expert-defined occurrence
> obs_OP <- ifelse(obs_OP == 0.75, 0.85, obs_OP) # boost same site P(occ) = 0.85 #2
> obs_OP <- ifelse(obs_OP == 0.5, 0.65, obs_OP) # boost country-habitat P(occ) = 0.65 #2
> obs_OP <- ifelse(obs_OP == 0.25, 0.35, obs_OP) # boost same habitat P(occ) = 0.45 #3 is 0.35 for #4
> obs_OP <- ifelse(obs_OP == 0, 0.1, obs_OP) #4
> 
> # -------------- STEP 1: Specifications. ------------ #
> 
> bias_cor <- TRUE # Performing bias correction.
> 
> Nsims <- 1000 #5000 # original 10000, reasonable 2500
> burn <- 5000 # 2000 # 22000 # original 40000, reasonable 2500
> thin <- 10 #5 # original 40
> use_H <- 10 # original 10
> theta_inf <- 0.01
> mh_n_pis <- 70  # Parameter for proposal in Metropolis-Hastings for pi update.
> mh_n_pjs <- 70
> mh_n_rho <- 100
> 
> # Prior distributions:
> stick_alpha <- 5
> prior_theta <- c(1, 1)
> prior_tau <- c(5, 5)
> prior_rho <- c(5, 5)  # I do not update this for now.
> prior_mu0 <- 0
> prior_sigmasq0 <- 10
> prior_sigmasq <- c(1, 1)
> 
> sampling <- NULL
> start_values <- NULL
> 
> # --------------- STEP 2: MCMC. ----------------- #
> 
> # We run 4 chains. We suggest that you run the following code in parallel instead.
> 
> nchains <- 2
> t1 <- Sys.time()
> 
> #cl <- parallel:makeCluster(nchains)
> doParallel::registerDoParallel(nchains)
> 
> foreach (cc = 1 : nchains) %dopar% {  # Chain index:
+   
+   ## Create a unique filename for each interation of the parallel loop
+   each_filename <- paste0('res_', date, '_', as.character(cc), '.dat') 
+   each_filepath <- file.path(save_path, each_filename)
+   
+   # If the file exists, skip to the next iteration
+   if (file.exists(each_filepath)) {
+     next
+   }
+   
+   set.seed(cc)
+   
+   mcmc <- MCMC.trim(obs_A = obs_A, focus = obs_F, occur_B = obs_OM, occur_P = obs_OP,
+                              obs_X = obs_X, obs_W = obs_W, Cu = Cu, Cv = Cv,
+                              Nsims = Nsims, burn = burn, thin = thin,
+                              use_H = use_H, bias_cor = bias_cor,use_shrinkage = TRUE,
+                              theta_inf = theta_inf, mh_n_pis = mh_n_pis,
+                              mh_n_pjs = mh_n_pjs, mh_n_rho = mh_n_rho,
+                              stick_alpha = stick_alpha, prior_theta = prior_theta,
+                              prior_tau = prior_tau, prior_rho = prior_rho,
+                              prior_mu0 = prior_mu0, prior_sigmasq0 = prior_sigmasq0,
+                              prior_sigmasq = prior_sigmasq, start_values = start_values,
+                              sampling = sampling, cut_feed = FALSE)
+ 
+   # Attaching the results:
+   #attach(mcmc)
+   
+   # Binding different predictions of interest: Posterior samples of the
+   # interaction indicators, the linear predictor of the interaction model,
+   # and the probability we use when sampling the interaction indicators.
+   # Studying MCMC() will clarify the three quantities.
+   # all_pred <- abind::abind(pred_L = mcmc$Ls, probL = mcmc$mod_pL1s, pL1s = mcmc$pL1s, along = 4)
+   all_pred <- abind::abind(pred_L = mcmc$Ls, probL = mcmc$mod_pL1s, along = 4)
+   
+   # Phylogenetic correlation parameter for bird and plant correlation matrices.
+   correlations <- cbind(U = mcmc$rU, V = mcmc$rV)
+   
+   # Running mean of detection probabilities
+   p_detect <- list(pis = mcmc$pi_mean, pjs = mcmc$pj_mean)
+   
+   # Running mean of latent factors
+   factors <- list(U = mcmc$U_mean, V = mcmc$V_mean)
+   
+   # Combining the results we are interested in to a list and saving:
+   res <- list(all_pred = all_pred, correlations = correlations, p_detect = p_detect, factors = factors)
+   #save(res, file = paste0(save_path, 'res_', date, "_", cc, '.dat'))
+   save(res, file = each_filepath)
+   
+   rm(res)
+ 
+ }
MCMC on 29 x 709 number of species.
MCMC on 29 x 709 number of species.
Total number of iterations: 15000
Total number of iterations: 15000
[1] 100
[1] 100
[1] 200
[1] 200
[1] 300
[1] 300
[1] 400
[1] 400
[1] 500
[1] 500
[1] 600
[1] 600
[1] 700
[1] 700
[1] 800
[1] 800
[1] 900
[1] 900
[1] 1000
[1] 1000
[1] 1100
[1] 1100
[1] 1200
[1] 1200
[1] 1300
[1] 1300
[1] 1400
[1] 1400
[1] 1500
[1] 1500
[1] 1600
[1] 1600
[1] 1700
[1] 1700
[1] 1800
[1] 1800
[1] 1900
[1] 1900
[1] 2000
[1] 2000
[1] 2100
[1] 2100
[1] 2200
[1] 2200
[1] 2300
[1] 2300
[1] 2400
[1] 2400
[1] 2500
[1] 2500
[1] 2600
[1] 2600
[1] 2700
[1] 2700
[1] 2800
[1] 2800
[1] 2900
[1] 2900
[1] 3000
[1] 3000
[1] 3100
[1] 3100
[1] 3200
[1] 3200
[1] 3300
[1] 3300
[1] 3400
[1] 3400
[1] 3500
[1] 3500
[1] 3600
[1] 3600
[1] 3700
[1] 3700
[1] 3800
[1] 3800
[1] 3900
[1] 3900
[1] 4000
[1] 4000
[1] 4100
[1] 4100
[1] 4200
[1] 4200
[1] 4300
[1] 4300
[1] 4400
[1] 4400
[1] 4500
[1] 4500
[1] 4600
[1] 4600
[1] 4700
[1] 4700
[1] 4800
[1] 4800
[1] 4900
[1] 4900
[1] 5000
[1] 5000
[1] 5100
[1] 5100
[1] 5200
[1] 5200
[1] 5300
[1] 5300
[1] 5400
[1] 5400
[1] 5500
[1] 5500
[1] 5600
[1] 5600
[1] 5700
[1] 5700
[1] 5800
[1] 5800
[1] 5900
[1] 5900
[1] 6000
[1] 6000
[1] 6100
[1] 6100
[1] 6200
[1] 6200
[1] 6300
[1] 6300
[1] 6400
[1] 6400
[1] 6500
[1] 6500
[1] 6600
[1] 6600
[1] 6700
[1] 6700
[1] 6800
[1] 6800
[1] 6900
[1] 6900
[1] 7000
[1] 7000
[1] 7100
[1] 7100
[1] 7200
[1] 7200
[1] 7300
[1] 7300
[1] 7400
[1] 7400
[1] 7500
[1] 7500
[1] 7600
[1] 7600
[1] 7700
[1] 7700
[1] 7800
[1] 7800
[1] 7900
[1] 7900
[1] 8000
[1] 8000
